@@@@ Masked Sbox(p+k) based on lookup table

  .syntax unified
  .text
  .thumb
  
  .extern sbox       @ lookup table

  @ The address of the "MaskedS" which is generated by 
  @ GenMaskedSbox function, MaskedSB(i+u)=SB(i)+v
  .extern MaskedS    

  .extern u          @ For masking the input (p+k) of SBOX
  .extern v          @ For masking the output (SBOX(p+k)) of SBOX
  

@@@@@ uint8_t Masked(uint8_t p, uint8_t k, uint8_t ms); For calculating:
@@@@@ MaskedSbox(p+k) based on lookup table 
@@@@@@@@ Masked(in_r0: p, in_r1: k, out_r0: ms)
@ r0 = &p, @ r1 = &k, @ r2 = &ms


.global Masked
.func Masked
Masked:
	push   {lr}
	push	 {r3-r7}

  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop

############################################
@@@@ Clearing registers
    eors  r3, r3        @ r3 = 0
    eors  r4, r4        @ r4 = 0
    eors  r5, r5        @ r5 = 0
    eors  r6, r6        @ r6 = 0
    eors  r7, r7        @ r7 = 0

############################################################
@@@@ Clearing write/read buses
    # mov  r4, #0         @ r4 = 0
    str  r4, [r2, #0]
    ldr  r4, [r2, #0]
############################################################
@ r0 = &p, @ r1 = &k, @ r2 = &ms
############################################################

    ldr  r5, =MaskedS   @ r5 = &MaskedS
    ldr  r4, [r2, #0]   @ Clearing the read bus
    ldr  r3, =u         @ r3 = &u
    ldr  r4, [r2, #0]   @ Clearing the read bus
    ldrb r7, [r3, #0]   @ r7 = u
    ldr  r4, [r2, #0]   @ Clearing the read bus
    ldr  r6, =v         @ r6 = &v 
    ldr  r4, [r2, #0]   @ Clearing the read bus
    eors r3, r3         @ Clearing r3, as it is &u
    ldrb r3, [r6, #0]   @ r3 = v 
    ldr  r4, [r2, #0]   @ Clearing the read bus
    eors r6, r6         @ Clearing r6, as it is &v
    ldrb r6, [r0, #0]   @ r6 = p
    ldr  r4, [r2, #0]   @ Clearing the read bus
    eors r0, r0         @ Clearing r0, as it is &p
    ldrb r0, [r1, #0]   @ r0 = k
    ldr  r4, [r2, #0]   @ Clearing the read bus

############################################################
@ r0 = k, r1 = &k, r2 = &ms, r3 = v,
@ r4 = 0, r5 = &MaskedS, r6 = p, r7 = u
############################################################

    eors r6, r0         @ r6 = p+k  (x=p)
    eors r6, r7         @ r6 = (p+k)+u

    # @ lsls: left shift: elements in sbox/MaskedS are 32bits, 
    # @ just the least significant byte (LSB) is desired,
    # @ the rest 24bits are set to zero, 
    # @ The address of the LSB is i*4
    lsls r6, r6, #2     @ r6 = (p+k+u)*4

    eors r1, r1         @ Clearing r1, as it is &k

    @@@@@@ MaskedS(x+k+u) = S(x+k) + v = mSB
    ldrb r1, [r5, r6]   @ r1 = msB = MaskedS[(p+k+u)*4]
    ldr  r4, [r2, #0]   @ Clearing the read bus

    @@@@@@  mSB + u = mSB1
    eors r1, r7         @ r1 = mSB + u = MaskedS[(p+k+u)*4]+u
    
    @@@@@ mSB1 + v 
    eors r1, r3

    strb r1, [r2, #0]




  nop
  nop
  nop
  nop
  nop
  nop
  nop
  nop
  @ Trigger
  @ scale.c: LPC13XX_GPIO1->GPIODATA &= ~( 0x1 <<  0 ) ; // initialise SCALE_GPIO_PIN_TRG = 0
  @ SCALE_GPIO_PIN_TRG in scale board: pin33: PIO1_0
  @ PIO1_0: https://www.digikey.pl/htmldatasheets/production/660585/0/0/1/lpc1311fhn33-551.html : 9.4 Register description
  @ baseaddress: 0x50010000, offset: 0x3ffc, baseaddress: 0x50010000, offset: 0x3ffc
  @ address: 0x5001ffc; producing this value: needs several instructions:
  @ https://developer.arm.com/documentation/den0042/a/Unified-Assembly-Language-Instructions/Instruction-set-basics/Constant-and-immediate-values
  @ Creating Trigger:                                       _____
  @ changing the value in add 0x5001ffc (0 --> 1 --> 0) ___|     |____ 
  

  @ Start of trigger
  movs r4, #80
  lsls r4, r4, #8
  movs r5, #1
  eors r4, r5  //0x5001
  lsls r4, #16 //0x50010000
  movs r5, #63 //0x3f
  lsls r5,r5,#8 //0x3f00
  eors r4,r5    //0x50013f00
  movs r5, #252
  eors r4,r5    //0x50013ffc
  movs r5,#1
  ldr  r6, [r4, #0]  @ r6 = 0 : SCALE_GPIO_PIN_TRG = 0
  # test: str  r6, [r3, #0]  @ r6 = 0xfc0f0000
  eors r5, r6  @ r5 = 1 @ Start trigger: SCALE_GPIO_PIN_TRG = 1
  str  r5, [r4, #0]
  # test: str  r5, [r3, #4] @ r6 = 0xfd0f0000
  nop
  nop
  nop
  nop
  str  r6, [r4, #0] @ End trigger: r6 = 0 : SCALE_GPIO_PIN_TRG = 0
	
  pop {r3-r7}
  pop {pc}
	
.endfunc



@@@@@ Modified GenMaskedSbox function in 
@@@@@https://github.com/sca-research/ASM_MaskedAES/blob/master/MaskedAES.S
@@ GenMaskedSbox create the table MaskedS (masked sbox):
@@ MaskedS(i+u) = sbox(i)+v  @ i = p+k
@@ MaskedS(j) = sbox(u+j)+v  @ i = p+k
@@ the input i is masked with u
@@ the output sbox(i) is masked with v
@@ the input and output are masked with different values


.global GenMaskedSbox
.func GenMaskedSbox
GenMaskedSbox:
  push {lr}
  push {r0-r7}

    eors r6, r6       @ r6 = 0, clear r6, as r6 will be used for MaskedS

    ldr  r0, =v       @ r0 = &v
    ldrb r7, [r0, #0] @ r7 = v
    
    ldr  r0, =u       @ r0 = &u
    ldrb r2, [r0, #0] @ r7 = u

  @@ MaskedS(i+u) = sbox(i)+v  @ i = p+k
  @@ MaskedS(j) = sbox(u+j)+v  @ i = p+k
    movs r3, #255     @ counter j (j = i+u) , 0 <= j <= 255, for all possible j
    ldr  r4, =sbox
    ldr  r5, =MaskedS

    masksbox:		@Create masked table
    @ r3 = j
    mov  r1, r3      @ r1 = j
    mov  r0, r3      @ r0 = j

    eors r1, r2      @ r1 = j+u = i

    # @ lsls: left shift: elements in sbox are 32bits, 
    # @ just the least significant byte (LSB) is desired,
    # @ the rest 24bits are set to zero, 
    # @ The address of the LSB is i*4

    lsls r1, r1, #2   @ r1 = (j+u)*4 = i*4
    ldr  r6, [r4, r1]	@ r6 = S[(j+u)*4] = S[i*4] @ loading all 32bits
    eors r6, r7	    	@ r6 = S[(j+u)*4]+v = S[i*4] +v

    # @ lsls: left shift: 
    # @ having same table like sbox for MaskedS, 
    # @ LSB is desired, the rest 24bits are set to zero
    # @ The address of the LSB is j*4
    lsls r0, r0, #2   @ r0 = j*4
    str  r6, [r5, r0]	@ MS[j*4] = S[(j+u)*4]+v = S[i*4] +v

    subs r3, #1		    @ j--
    bge.n masksbox 
  
  pop {r0-r7}
  pop {pc}

  .endfunc


.end
